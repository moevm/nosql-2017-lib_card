Memcached: инофрмация о каждой карточке хранится по отдельному ключу. Ключ - идентификатор карточки. Значение - переведённый в строку объект Python - словарь с ключами "Название", "Автор", "Год издания", "История выдачи", по ключу "История выдачи" будет хранится список словарей с ключами "ФИО читателя", "Дата выдачи", "Дата возврата". У последнего элемента поле "Дата возврата" может быть None - это означает, что читатель ещё не вернул книгу.

Neo4j: Для каждого набора книг, имеющих одинаковые названия, авторов и года выпуска, существует отдельная вершина с атрибутами "Название", "Автор", "Год выпуска". Каждая карточка представляется отдельной вершиной, имеющей атрибуты "Идентификатор" и "История выдачи". Поле "История выдачи" является json - списком, у элементов которого есть поля "ФИО читателя" и "Дата выдачи", "Дата возврата". У последнего элемента поле "Дата возврата" может быть null - это означает, что читатель ещё не вернул книгу. Каждая карточка имеет связь с соответствующей ей книгой.

MongoDB: Каждая карточка представляет собой отдельный документ. Идентификатором документа явялется идентификатор карточки. В документе есть поля "Название", "Автор", "Год выпуска", "История выдачи". Поле "История выдачи" является списком, у элементов которого есть поля "ФИО читателя" и "Дата выдачи", "Дата возврата". У последнего элемента поле "Дата возврата" может быть null - это означает, что читатель ещё не вернул книгу.

В реляционных базах данных это можно сделать с помощью таблиц:
1) Множество всех книг с идентификатором, названием, годом издания, автором, ссылкой на изображение.
2) Все книги с идентификатором конкретной книги, идентификатором из множества книг.
3) История выдачи всех книг с идентификатором конкретной книги, датой выдачи, датой возврата.

Пусть совокупность полей ("Название, "Год выпуска", "Автор", "Изображение") занимает N памяти, M - число доступных книг, K - количество памяти, занимаемое совокупностью полей ("Дата выдачи", "Дата возврата"), H - среднее количество выдач и возвратов всех книг, P - среднее количество экземпляров каждой книги.

Тогда хранение данных
1) В memcached будет занимать M * P * N + M * P * H * K
2) В Neo4j будет занимать M * N + M * P * H * K
3) В MongoDB будет занимать M * P * N + M * P * H * K
4) В реляционных базах данных будет занимать M * N + M * P * H * K

Тогда при условии того, что N = (50 байт строка + 2 байта число + 18 байт автор), число доступных книг M = 300, K = (10 байт дата выдачи + 10 байт дата возврата), среднее количество выдач и возвратов всех книг H = 20, среднее количество экземпляров каждой книги P = 3

Тогда хранение данных будет занимать
1) В memcached - 300 * 3 * 70 + 300 * 3 * 20 * 20 = 423000 байт
2) В Neo4j - 300 * 70 + 3 * 20 * 20 = 381000 байт
3) В MongoDB - 423000 байт
4) В реляционных базах данных - 381000 байт

Таким образом, реляционные базы и Neo4j выигрывают, а memcached и MongoDB проигрывают по памяти

Запрос на поиск полей книги по идентификатору конкретной книги
1) В memcached будет занимать O(1)
2) В Neo4j будет занимать O(M * P)
3) В MongoDB будет занимать O(M * P)
4) В реляционных базах необходимо сделать 1 join, по таблице с идентификатором и таблице с книгами, сложность поиска O( (M * P) * M )

Запрос на поиск всей истории выдачи по идентификатору конкретной книги
1) В memcached будет занимать O(1)
2) В Neo4j будет занимать O(M * P)
3) В MongoDB будет занимать O(M * P)
4) В реляционных базах необходимо сделать 1 join, по истории выдачи и таблице с идентификаторами, сложность поиска O( (M * P) * (M * P * H))

Таким образом, memcached работает быстрее всех, Neo4j и MongoDB на втором месте, хуже всех реляционные базы данных.

Примеры на добавление карточки с идентификатором 1, автором A, годом 2017, названием B и ссылкой на изображение C
1) memcached - "add 1 0 0 42 \r\n{year:2017,author:"A",name:"B",history:[]}, "image" : "C"\r"
2) Neo4j - "CREATE (card:Card {id: "1", histoty: "null","image" : "C"}) \
MERGE (book:Book {title: "B", releaseDate: "2017", author: "A"}) \
MERGE (card)--(book)"
3) MongoDB - "db.library.insertOne({_id:1,title:"B",releaseDate:"2017",author:"A",histoty:"null","image" : "C"})"

Примеры на удаление карточки с идентификатором 1:
1) memcached - "delete 1\r"
2) Neo4j - "MATCH (book:Book)-[rel]-(card:Card {id: 1}) DELETE book, rel"
3) MongoDB - "db.library.remove({_id : 1})"

Примеры на поиск истории по идентификатору карточки:
1) memcached - "get 1\r"
2) Neo4j - "MATCH (card:Card {id: 1}) RETURN card.history AS history"
3) MongoDB - "db.library.find({_id: 1}"
